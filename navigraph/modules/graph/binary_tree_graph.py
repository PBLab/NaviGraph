# binary_tree_graph.py
import numpy as np
import logging
from typing import Any, Callable
from omegaconf import DictConfig
import networkx as nx
import random
from graph_datasource import GraphDatasource
from graph_node import Node  # We'll use basic Node; if needed, TileNode can be used.
from graph_visualizer import GraphVisualizer
from pyvis_visualizer import PyVisVisualizer
from session_module_base import register_module


@register_module
class BinaryTreeGraph(GraphDatasource):
    """
    A concrete graph datasource that builds a binary tree.

    Nodes are created with a basic Node (or could be TileNodes if tile_id is provided via mapping).
    This implementation uses a rolling average to compute x-positions.
    """

    def __init__(self, cfg: DictConfig, weight_func: Callable[[int, int], float] = None, **kwargs: Any) -> None:
        super().__init__(cfg, **kwargs)
        self.height: int = self.cfg.graph.height
        self.weight_func: Callable[[int, int], float] = weight_func if weight_func is not None else (lambda p, c: 1)
        self.graph = self.build_graph()
        self.logger.info("BinaryTreeGraph built with height %d", self.height)

    def build_graph(self) -> nx.Graph:
        """
        Build a binary tree graph.

        Node ids are generated by concatenating the level and index.
        Positions are computed using a rolling average for x-coordinates.
        """
        g = nx.Graph()
        height = self.height
        x_pos = np.arange(2 ** height)
        get_x_pos = lambda x: np.convolve(x, np.ones(2), 'valid') / 2
        # Build levels from bottom (level = height-1) to top (level = 0)
        for level in range(height)[::-1]:
            num_nodes = 2 ** level
            if level == height - 1:
                x_positions = np.arange(2 ** height)
            else:
                x_positions = get_x_pos(x_pos)[::2]
                x_pos = x_positions
            for i in range(num_nodes):
                node_id = int(f"{level}{i}")
                pos = (x_positions[i], height - level)
                # Here we create a basic Node. To associate a tile, you might add tile_id later.
                g.add_node(node_id, data=Node(node_id=node_id, name=str(node_id)))
                g.nodes[node_id]['pos'] = pos
                if level == height - 1:
                    continue
                left_child = int(f"{level + 1}{2 * i}")
                right_child = int(f"{level + 1}{2 * i + 1}")
                g.add_edge(node_id, left_child, weight=self.weight_func(node_id, left_child))
                g.add_edge(node_id, right_child, weight=self.weight_func(node_id, right_child))

        return g

    def get_visualizer(self) -> GraphVisualizer:
        """
        Return a PyVis-based visualizers.
        """
        return PyVisVisualizer()

    def augment_dataframe(self, df: Any) -> Any:
        """
        Augment the provided DataFrame with graph-related information.

        If the DataFrame contains a 'tile_id' column, a new column 'graph_node' is added
        which maps each tile_id to the corresponding node id.
        """
        if "tile_id" in df.columns:
            df["graph_node"] = df["tile_id"].apply(lambda tid: self.get_graph_location(tid))
            self.logger.info("Augmented dataframe with 'graph_node' column.")
        else:
            self.logger.warning("DataFrame does not contain 'tile_id' column; skipping augmentation.")
        return df

    @classmethod
    def from_config(cls, config: dict) -> "BinaryTreeGraph":
        height = config.get("graph", {}).get("height", 3)
        return cls(cfg=config)
